#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Like qstat, but customised.

"""

import argparse
import signal
import sys
from datetime import datetime
from os.path import dirname, realpath

from dateutil.parser import parse

# Put the parent directory first in the path
sys.path.insert(1, dirname(dirname(realpath(__file__))))
from wsge.qstat import qstat

# If output goes into head or less without finishing, it will terminate with
# IOError, this makes pipe errors get ignored.
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

def commandline():
    """Commandline options in here."""
    DESCRIPTION = """Wooki job info with a nicer output than qstat."""
    # use description for the script, not for this module
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument("-u", "--user", nargs='+',
                        help="User or list of users to show jobs for.")
    options = parser.parse_args()

    return options


def main():

    # Get data
    jobs = qstat()
    options = commandline()

    # how wide?
    name_width = max(len(x['JB_name']) for x in jobs)

    # header              "xky        "      job age             t
    print("job-ID   prior    user          state  run/wait time      queue "
          "           slots  %-*s" % (name_width, 'name'))
    print("-"*(82+name_width))

    # Get rid of the microseconds so that the output is only reported to the
    # second
    now = datetime.now().replace(microsecond=0)

    # Track if we are in pending jobs to add a separator
    pending_break = False
    for job in jobs:
        # Skip unwanted users if users requested
        if options.user is not None and job['JB_owner'] not in options.user:
            continue

        if not pending_break and 'q' in job['state']:
            print("-"*(82+name_width))
            pending_break = True

        # Parse the dates into deltas -> more useful?
        try:
            runtime = now - parse(job['JAT_start_time'])
        except KeyError:
            runtime = now - parse(job['JB_submission_time'])

        # non running jobs have no queue
        if job['queue_name'] is not None:
            queue = job['queue_name'].split('@')[1].split('.')[0]
        else:
            queue = ''

        print("{0[JB_job_number]:<7s}  {0[JAT_prio]:<7s}  {0[JB_owner]:<12}  "
              "{0[state]:<5s}  {runtime:>17s}  {queue:<15}  {0[slots]:>5}  "
              "{0[JB_name]:<{name_width}s}".format(job, name_width=name_width,
                                                   runtime=runtime, queue=queue))

    return

if __name__ == '__main__':
    main()
