#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Wooki job info.

Shows job information, like qstat, but customised for jobs on the local
cluster. Shows all user jobs by default, use the '--user' argument to
specify a user or list of users to show jobs for.

"""

import argparse
import re
import signal
import sys
from datetime import datetime
from os.path import dirname, realpath

from dateutil.parser import parse

# Put the parent directory first in the path
sys.path.insert(1, dirname(dirname(realpath(__file__))))
from wsge.qstat import qstat

# If output goes into head or less without finishing, it will terminate with
# IOError, this makes pipe errors get ignored.
signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def commandline():
    """Process commandline options in here. Return the argparse object."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-u", "--user", nargs='+',
                        help="User or list of users to show jobs for. Names "
                        "may use regular expressions for wildcard matches.")
    options = parser.parse_args()

    return options


def main():
    """Process qstat and print formatted output to terminal."""

    # Get data
    jobs = qstat()
    options = commandline()

    # Use regular expressions to prune the job list
    if options.user is not None:
        user_regexes = [re.compile('^{}$'.format(user_regex))
                        for user_regex in options.user]
        jobs = [job for job in jobs if
                any(user_regex.match(job['JB_owner'])
                    for user_regex in user_regexes)]

    # how wide? include 8 for empty case so header looks reasonable
    name_width = max([8] + [len(job['JB_name']) for job in jobs])

    # header              "xky        "      job age             t
    print("job-ID   prior    user          state  run/wait time      queue "
          "           slots  %-*s" % (name_width, 'name'))
    print("-"*(82+name_width))

    # Get rid of the microseconds so that the output is only reported to the
    # second
    now = datetime.now().replace(microsecond=0)

    # Track if we are in pending jobs to add a separator
    pending_break = False
    for job in jobs:
        if not pending_break and 'q' in job['state']:
            print("-"*(82+name_width))
            pending_break = True

        # Parse the dates into deltas -> more useful?
        try:
            runtime = now - parse(job['JAT_start_time'])
        except KeyError:
            runtime = now - parse(job['JB_submission_time'])

        # non running jobs have no queue
        if job['queue_name'] is not None:
            queue = job['queue_name'].split('@')[1].split('.')[0]
        else:
            queue = ''

        print("{0[JB_job_number]:<7s}  {0[JAT_prio]:<7s}  {0[JB_owner]:<12}  "
              "{0[state]:<5s}  {runtime:>17s}  {queue:<15}  {0[slots]:>5}  "
              "{0[JB_name]:<s}".format(job, runtime=runtime, queue=queue))

    return

if __name__ == '__main__':
    main()
